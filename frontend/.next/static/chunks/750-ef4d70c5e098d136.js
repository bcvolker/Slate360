"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[750],{9231:function(e,t,a){a.d(t,{jp:function(){return u}});var s=a(2265),n=a(2749),r=a(7868);class c extends r.ZP{async getProject(e){return await this.projects.get(e)}async getAllProjects(){return await this.projects.toArray()}async getProjectsByFilter(e){let t=this.projects.toCollection();if(e.status&&(t=t.filter(t=>t.status===e.status)),e.type&&(t=t.filter(t=>t.type===e.type)),e.client&&(t=t.filter(t=>{var a;return t.client.name.toLowerCase().includes(e.client.toLowerCase())||(null===(a=t.client.company)||void 0===a?void 0:a.toLowerCase().includes(e.client.toLowerCase()))})),e.search){let a=e.search.toLowerCase();t=t.filter(e=>{var t;return e.name.toLowerCase().includes(a)||e.description.toLowerCase().includes(a)||e.client.name.toLowerCase().includes(a)||(null===(t=e.client.company)||void 0===t?void 0:t.toLowerCase().includes(a))||e.tags.some(e=>e.toLowerCase().includes(a))})}return e.createdBy&&(t=t.filter(t=>t.createdBy===e.createdBy)),await t.toArray()}async getSyncStatus(){let e=await this.projects.toArray(),t=await this.syncMetadata.get("lastSync");return{totalProjects:e.length,syncedProjects:e.filter(e=>"synced"===e._syncStatus).length,pendingProjects:e.filter(e=>"pending"===e._syncStatus).length,failedProjects:e.filter(e=>"failed"===e._syncStatus).length,lastSync:null==t?void 0:t.value}}async getPendingSyncItems(){return await this.syncQueue.where("retryCount").below(3).toArray()}async clearOldSyncData(){let e=new Date;e.setDate(e.getDate()-30),await this.projects.where("_lastSync").below(e).and(e=>"synced"===e._syncStatus).delete()}constructor(){super("ProjectDatabase"),this.version(1).stores({projects:"_id, _offlineId, _syncStatus, status, type, createdBy, _lastSync",syncQueue:"++id, type, entityType, entityId, timestamp, retryCount",syncMetadata:"key"}),this.version(2).stores({projects:"_id, _offlineId, _syncStatus, status, type, createdBy, _lastSync, name, client.name, tags"})}}let i=new c;var o=a(5925);class l{updateStatus(e){this.isOnline=e,this.listeners.forEach(t=>t(e)),e?(o.Am.success("Back online! Syncing data..."),this.triggerSync()):o.Am.error("You're offline. Changes will be saved locally.")}getStatus(){return this.isOnline}addListener(e){return this.listeners.push(e),()=>{let t=this.listeners.indexOf(e);t>-1&&this.listeners.splice(t,1)}}async triggerSync(){try{await d.syncPendingChanges()}catch(e){console.error("Auto-sync failed:",e)}}constructor(){this.isOnline=navigator.onLine,this.listeners=[],window.addEventListener("online",()=>this.updateStatus(!0)),window.addEventListener("offline",()=>this.updateStatus(!1))}}class d{static initialize(){this.networkManager.addListener(e=>{e?this.startPeriodicSync():this.stopPeriodicSync()}),this.networkManager.getStatus()&&this.startPeriodicSync(),this.syncFromServer()}static startPeriodicSync(){this.syncInterval||(this.syncInterval=setInterval(async()=>{if(this.networkManager.getStatus()&&!this.syncInProgress)try{await this.syncPendingChanges()}catch(e){console.error("Periodic sync failed:",e)}},3e4))}static stopPeriodicSync(){this.syncInterval&&(clearInterval(this.syncInterval),this.syncInterval=null)}static isOnline(){return this.networkManager.getStatus()}static onNetworkChange(e){return this.networkManager.addListener(e)}static async syncFromServer(){if(!this.networkManager.getStatus()){console.log("Offline - skipping server sync");return}try{let e=await fetch("/api/projects?limit=1000");if(e.ok){let t=(await e.json()).projects,a=await i.getAllProjects(),s=new Map(a.map(e=>[e._id,e]));for(let e of t){let t=s.get(e._id);if(!t||this.isServerVersionNewer(e,t)){let a={...e,_syncStatus:"synced",_lastSync:new Date,_offlineChanges:(null==t?void 0:t._offlineChanges)||[]};await i.projects.put(a)}}await i.syncMetadata.put({key:"lastSync",value:new Date}),console.log("Synced ".concat(t.length," projects from server"))}}catch(e){throw console.error("Failed to sync from server:",e),e}}static isServerVersionNewer(e,t){return new Date(e.updatedAt)>new Date(t.updatedAt)}static async syncPendingChanges(){if(!this.networkManager.getStatus()){console.log("Offline - skipping sync to server");return}if(this.syncInProgress){console.log("Sync already in progress");return}this.syncInProgress=!0;try{let e=await i.getPendingSyncItems();if(0===e.length){console.log("No pending sync items");return}for(let t of(console.log("Syncing ".concat(e.length," pending changes")),e))try{await this.processSyncItem(t),await i.syncQueue.delete(t.id)}catch(e){console.error("Failed to sync item ".concat(t.id,":"),e),await i.syncQueue.update(t.id,{retryCount:t.retryCount+1,lastAttempt:new Date})}await this.updateProjectSyncStatuses()}finally{this.syncInProgress=!1}}static async processSyncItem(e){switch(e.type){case"create":await this.createProjectOnServer(e);break;case"update":await this.updateProjectOnServer(e);break;case"delete":await this.deleteProjectOnServer(e)}}static async createProjectOnServer(e){let t=await fetch("/api/projects",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e.data)});if(!t.ok)throw Error("Failed to create project: ".concat(t.statusText));let a=await t.json();await i.projects.update(e.entityId,{_id:a.project._id,_syncStatus:"synced",_lastSync:new Date})}static async updateProjectOnServer(e){let t=await fetch("/api/projects/".concat(e.entityId),{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e.data)});if(!t.ok)throw Error("Failed to update project: ".concat(t.statusText));await i.projects.update(e.entityId,{_syncStatus:"synced",_lastSync:new Date})}static async deleteProjectOnServer(e){let t=await fetch("/api/projects/".concat(e.entityId),{method:"DELETE"});if(!t.ok)throw Error("Failed to delete project: ".concat(t.statusText));await i.projects.delete(e.entityId)}static async updateProjectSyncStatuses(){for(let e of(await i.getAllProjects()))"pending"===e._syncStatus&&0===(await i.syncQueue.where("entityId").equals(e._id).toArray()).length&&await i.projects.update(e._id,{_syncStatus:"synced",_lastSync:new Date})}static async createProject(e){let t="offline_".concat(Date.now(),"_").concat(Math.random().toString(36).substr(2,9)),a={...e,_id:t,_offlineId:t,_syncStatus:"pending",_lastSync:new Date,_offlineChanges:[{type:"create",timestamp:new Date,data:e}]};return await i.projects.add(a),await i.syncQueue.add({type:"create",entityType:"project",entityId:t,data:e,timestamp:new Date,retryCount:0}),this.networkManager.getStatus()&&this.syncPendingChanges().catch(console.error),a}static async updateProject(e,t){let a=await i.projects.get(e);if(!a)throw Error("Project not found");let s={...a,...t,_syncStatus:"pending",_lastSync:new Date,_offlineChanges:[...a._offlineChanges||[],{type:"update",timestamp:new Date,data:t}]};return await i.projects.put(s),await i.syncQueue.add({type:"update",entityType:"project",entityId:e,data:t,timestamp:new Date,retryCount:0}),this.networkManager.getStatus()&&this.syncPendingChanges().catch(console.error),s}static async deleteProject(e){let t=await i.projects.get(e);if(!t)throw Error("Project not found");await i.projects.update(e,{_syncStatus:"pending",_lastSync:new Date,_offlineChanges:[...t._offlineChanges||[],{type:"delete",timestamp:new Date}]}),await i.syncQueue.add({type:"delete",entityType:"project",entityId:e,timestamp:new Date,retryCount:0}),this.networkManager.getStatus()&&this.syncPendingChanges().catch(console.error)}static async getSyncStatus(){return await i.getSyncStatus()}static async forceSync(){if(!this.networkManager.getStatus())throw Error("Cannot sync while offline");await this.syncFromServer(),await this.syncPendingChanges()}static async clearOldData(){await i.clearOldSyncData()}}d.networkManager=new l,d.syncInProgress=!1,d.syncInterval=null;let y=d.networkManager;function u(){let{data:e}=(0,n.useSession)(),[t,a]=(0,s.useState)([]),[r,c]=(0,s.useState)(!0),[l,u]=(0,s.useState)(null),[w,h]=(0,s.useState)(y.getStatus()),[p,f]=(0,s.useState)(null);(0,s.useEffect)(()=>{(null==e?void 0:e.user)&&g()},[null==e?void 0:e.user]),(0,s.useEffect)(()=>d.onNetworkChange(e=>{h(e),e&&j()}),[]);let g=async()=>{try{c(!0),u(null),d.initialize(),await S(),await j()}catch(e){u(e instanceof Error?e.message:"Failed to initialize offline projects"),console.error("Failed to initialize offline projects:",e)}finally{c(!1)}},S=async()=>{try{let e=await i.getAllProjects();a(e)}catch(e){throw console.error("Failed to load local projects:",e),e}},j=async()=>{try{let e=await d.getSyncStatus();f(e)}catch(e){console.error("Failed to refresh sync status:",e)}},m=(0,s.useCallback)(async e=>{try{u(null);let t=await d.createProject(e);return a(e=>[t,...e]),w?o.Am.success("Project created and synced to server"):o.Am.success("Project created offline. Will sync when online."),await j(),t}catch(t){let e=t instanceof Error?t.message:"Failed to create project";throw u(e),o.Am.error(e),t}},[w]),v=(0,s.useCallback)(async(e,t)=>{try{u(null);let s=await d.updateProject(e,t);return a(t=>t.map(t=>t._id===e?s:t)),w?o.Am.success("Project updated and synced to server"):o.Am.success("Project updated offline. Will sync when online."),await j(),s}catch(t){let e=t instanceof Error?t.message:"Failed to update project";throw u(e),o.Am.error(e),t}},[w]),P=(0,s.useCallback)(async e=>{try{u(null),await d.deleteProject(e),a(t=>t.filter(t=>t._id!==e)),w?o.Am.success("Project deleted and synced to server"):o.Am.success("Project deleted offline. Will sync when online."),await j()}catch(t){let e=t instanceof Error?t.message:"Failed to delete project";throw u(e),o.Am.error(e),t}},[w]),_=(0,s.useCallback)(async()=>{try{c(!0),u(null),await S(),await j()}catch(t){let e=t instanceof Error?t.message:"Failed to refresh projects";u(e),o.Am.error(e)}finally{c(!1)}},[]),C=(0,s.useCallback)(async()=>{try{if(u(null),c(!0),!w)throw Error("Cannot sync while offline");o.Am.loading("Syncing with server..."),await d.forceSync(),await S(),await j(),o.Am.dismiss(),o.Am.success("Sync completed successfully")}catch(t){let e=t instanceof Error?t.message:"Failed to sync with server";throw u(e),o.Am.dismiss(),o.Am.error(e),t}finally{c(!1)}},[w]),k=(0,s.useCallback)(e=>t.find(t=>t._id===e),[t]);return{projects:t,loading:r,error:l,isOnline:w,syncStatus:p,createProject:m,updateProject:v,deleteProject:P,refreshProjects:_,forceSync:C,getProject:k,getProjectsByFilter:(0,s.useCallback)(async e=>{try{return await i.getProjectsByFilter(e)}catch(e){throw console.error("Failed to filter projects:",e),e}},[]),clearOldData:(0,s.useCallback)(async()=>{try{await d.clearOldData(),await S(),await j(),o.Am.success("Old data cleared successfully")}catch(t){let e=t instanceof Error?t.message:"Failed to clear old data";throw o.Am.error(e),t}},[])}}},8064:function(e,t,a){a.d(t,{qs:function(){return r}}),a(7437);var s=a(2749),n=a(4033);function r(){var e,t;let{data:a,status:r}=(0,s.useSession)();(0,n.useRouter)();let c="authenticated"===r,i=(null==a?void 0:null===(e=a.user)||void 0===e?void 0:e.role)||null,o=(null==a?void 0:null===(t=a.user)||void 0===t?void 0:t.tier)||null,l="ceo"===i,d="admin"===i||"ceo"===i,y="premium"===o||"enterprise"===o,u="enterprise"===o;return{isAuthenticated:c,userRole:i,userTier:o,isCEO:l,isAdmin:d,isPremium:y,isEnterprise:u,canAccessFeature:e=>{if(!c)return!1;switch(e){case"project-hub":return!0;case"bim-viewer":case"360-tours":return y;case"vr-ar":case"geospatial":return u;case"ceo-dashboard":return l;case"admin-panel":return d;default:return!1}}}}}}]);